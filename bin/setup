#!/usr/bin/env bash
# bin/setup - Install review-code from local repository
#
# Usage:
#   bin/setup
#
# Description:
#   Installs review-code by copying files from current directory to:
#   - ~/.claude/commands/ - Command files
#   - ~/.claude/agents/ - Agent files
#   - ~/.claude/bin/ - Helper scripts
#   - {REVIEW_PATH}/context/ - Context files (preserves user edits)
#
#   This script can be run repeatedly during development.
#
# Prerequisites:
#   - bash 4.0+
#   - git
#   - gh (GitHub CLI)
#   - jq
#   - ~/.claude directory

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Directories
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
CLAUDE_DIR="$HOME/.claude"
CONFIG_FILE="$CLAUDE_DIR/review-code.env"
DEFAULT_REVIEW_PATH="$HOME/dev/ai/reviews"

# Functions
info() {
    echo -e "${GREEN}✓${NC} $1"
}

warn() {
    echo -e "${YELLOW}⚠${NC} $1"
}

error() {
    echo -e "${RED}✗${NC} $1"
}

debug() {
    echo -e "${BLUE}→${NC} $1"
}

check_prerequisites() {
    local missing=()

    # Check bash version
    if [ "${BASH_VERSINFO[0]}" -lt 4 ]; then
        missing+=("bash 4.0+")
    fi

    # Check required commands
    for cmd in git gh jq; do
        if ! command -v "$cmd" &> /dev/null; then
            missing+=("$cmd")
        fi
    done

    # Check ~/.claude directory
    if [ ! -d "$CLAUDE_DIR" ]; then
        missing+=("$HOME/.claude directory (install Claude Code first)")
    fi

    if [ ${#missing[@]} -gt 0 ]; then
        error "Missing prerequisites:"
        for item in "${missing[@]}"; do
            echo "  - $item"
        done
        echo ""
        echo "Install instructions:"
        echo "  - bash 4.0+: brew install bash"
        echo "  - git: brew install git"
        echo "  - gh: brew install gh"
        echo "  - jq: brew install jq"
        exit 1
    fi
}

verify_repo_structure() {
    local required_dirs=("lib" "agents" "commands" "context")
    local missing=()

    for dir in "${required_dirs[@]}"; do
        if [ ! -d "$SCRIPT_DIR/$dir" ]; then
            missing+=("$dir/")
        fi
    done

    if [ ${#missing[@]} -gt 0 ]; then
        error "Missing required directories:"
        for item in "${missing[@]}"; do
            echo "  - $item"
        done
        echo ""
        echo "Are you running this from the review-code repository root?"
        exit 1
    fi
}

# Safely load configuration from file without executing arbitrary code
load_config_safely() {
    local config_file="$1"

    [ ! -f "$config_file" ] && return 0

    # Validate file permissions for security
    local file_owner
    local file_perms

    if [[ "$OSTYPE" == "darwin"* ]]; then
        file_owner=$(stat -f '%u' "$config_file" 2> /dev/null)
        file_perms=$(stat -f '%Lp' "$config_file" 2> /dev/null)
    else
        file_owner=$(stat -c '%u' "$config_file" 2> /dev/null)
        file_perms=$(stat -c '%a' "$config_file" 2> /dev/null)
    fi

    if [ "$file_owner" != "$(id -u)" ]; then
        error "Config file not owned by current user: $config_file"
        return 1
    fi

    local world_perms=$((file_perms % 10))
    if [ $((world_perms & 2)) -ne 0 ]; then
        error "Config file is world-writable: $config_file"
        error "Fix with: chmod o-w $config_file"
        return 1
    fi

    # Parse configuration safely
    while IFS='=' read -r key value; do
        [[ "$key" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$key" ]] && continue
        [[ ! "$key" =~ ^[A-Z_][A-Z0-9_]*$ ]] && continue

        value="${value#\"}"
        value="${value%\"}"
        value="${value#\'}"
        value="${value%\'}"

        case "$key" in
            REVIEW_ROOT_PATH) export REVIEW_ROOT_PATH="$value" ;;
            CONTEXT_PATH) export CONTEXT_PATH="$value" ;;
            DIFF_CONTEXT_LINES) export DIFF_CONTEXT_LINES="$value" ;;
            CACHE_TTL_HOURS) export CACHE_TTL_HOURS="$value" ;;
        esac
    done < "$config_file"

    return 0
}

get_review_path() {
    local review_path=""

    # Check if config already exists
    if [ -f "$CONFIG_FILE" ]; then
        load_config_safely "$CONFIG_FILE"
        review_path="${REVIEW_ROOT_PATH:-}"
        if [ -n "$review_path" ]; then
            # If path exists and is writable, use it without prompting
            # Expand tilde if present
            local expanded_path="${review_path/#\~/$HOME}"
            if [ -d "$expanded_path" ] && [ -w "$expanded_path" ]; then
                info "Using existing review path: $review_path" >&2
                echo "$review_path"
                return
            fi

            # Path in config is invalid, prompt user
            echo "" >&2
            warn "Configured path doesn't exist or isn't writable: $review_path"
            read -p "Enter a new path? [Y/n] " -n 1 -r
            echo "" >&2
            if [[ $REPLY =~ ^[Nn]$ ]]; then
                error "Installation cancelled"
                exit 1
            fi
        fi
    fi

    # Prompt for new path
    echo "" >&2
    echo "Where should code reviews and context files be saved?" >&2
    read -p "Review path [$DEFAULT_REVIEW_PATH]: " review_path
    review_path="${review_path:-$DEFAULT_REVIEW_PATH}"

    # Expand tilde
    review_path="${review_path/#\~/$HOME}"

    # Validate and create directory
    if [ ! -d "$review_path" ]; then
        read -p "Directory doesn't exist. Create it? [Y/n] " -n 1 -r
        echo "" >&2
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            mkdir -p "$review_path"
            info "Created directory: $review_path"
        else
            error "Installation cancelled"
            exit 1
        fi
    fi

    # Check if writable
    if [ ! -w "$review_path" ]; then
        error "Directory is not writable: $review_path"
        exit 1
    fi

    echo "$review_path"
}

create_config() {
    local review_path="$1"
    local context_path="$review_path/context"

    # Create .claude directory if it doesn't exist
    mkdir -p "$CLAUDE_DIR"

    # Write config file
    cat > "$CONFIG_FILE" << EOF
# Claude Code review-code command configuration
# Generated by bin/setup
#
# Root directory where code reviews are saved
# Reviews are organized as: {REVIEW_ROOT_PATH}/{org}/{repo}/{pr-number-or-branch}.md
REVIEW_ROOT_PATH="$review_path"

# Directory where context files are stored (language/framework/org-specific guidelines)
# These files can be customized by users
CONTEXT_PATH="$context_path"
EOF

    info "Configuration saved to: $CONFIG_FILE"
}

install_commands() {
    local src="$SCRIPT_DIR/commands/review-code.md"
    local dst="$CLAUDE_DIR/commands/review-code.md"

    # Create commands directory
    mkdir -p "$CLAUDE_DIR/commands"

    # Backup existing file if not a symlink
    if [ -f "$dst" ] && [ ! -L "$dst" ]; then
        debug "Backing up existing review-code.md"
        cp "$dst" "$dst.bak"
    fi

    # Remove old symlink if exists
    if [ -L "$dst" ]; then
        rm "$dst"
    fi

    # Copy file
    cp "$src" "$dst"
    info "Installed command: review-code"
}

install_agents() {
    local agents=(
        "code-review-context-explorer"
        "code-reviewer-security"
        "code-reviewer-performance"
        "code-reviewer-maintainability"
        "code-reviewer-testing"
        "code-reviewer-compatibility"
        "code-reviewer-architecture"
    )

    # Create agents directory
    mkdir -p "$CLAUDE_DIR/agents"

    for agent in "${agents[@]}"; do
        local src="$SCRIPT_DIR/agents/${agent}.md"
        local dst="$CLAUDE_DIR/agents/${agent}.md"

        # Backup existing file if not a symlink
        if [ -f "$dst" ] && [ ! -L "$dst" ]; then
            cp "$dst" "$dst.bak"
        fi

        # Remove old symlink if exists
        if [ -L "$dst" ]; then
            rm "$dst"
        fi

        # Copy file
        cp "$src" "$dst"
    done

    info "Installed ${#agents[@]} agents (6 reviewers + 1 context explorer)"
}

install_scripts() {
    local scripts=(
        "git-context.sh"
        "git-diff-filter.sh"
        "git-diff-context.sh"
        "pr-context.sh"
        "code-language-detect.sh"
        "load-review-context.sh"
        "review-file-path.sh"
        "pre-review-context.sh"
        "parse-review-arg.sh"
        "get-review-diff.sh"
        "review-orchestrator.sh"
    )

    # Create review-code bin subdirectory
    mkdir -p "$CLAUDE_DIR/bin/review-code"
    mkdir -p "$CLAUDE_DIR/bin/review-code/helpers"

    # Copy main scripts
    for script in "${scripts[@]}"; do
        local src="$SCRIPT_DIR/lib/$script"
        local dst="$CLAUDE_DIR/bin/review-code/$script"

        if [ ! -f "$src" ]; then
            error "Missing script: $script"
            exit 1
        fi

        cp "$src" "$dst"
        chmod +x "$dst"
    done

    # Copy helper directory
    if [ -d "$SCRIPT_DIR/lib/helpers" ]; then
        cp -r "$SCRIPT_DIR/lib/helpers/"* "$CLAUDE_DIR/bin/review-code/helpers/" 2> /dev/null || true
        chmod +x "$CLAUDE_DIR/bin/review-code/helpers/"*.sh 2> /dev/null || true
    fi

    # Copy uninstall script to main bin (not in subfolder)
    if [ -f "$SCRIPT_DIR/uninstall.sh" ]; then
        cp "$SCRIPT_DIR/uninstall.sh" "$CLAUDE_DIR/bin/uninstall-review-code.sh"
        chmod +x "$CLAUDE_DIR/bin/uninstall-review-code.sh"
    fi

    info "Installed ${#scripts[@]} helper scripts"
}

get_file_checksum() {
    local file="$1"
    if [ -f "$file" ]; then
        # Use md5 on macOS, md5sum on Linux
        if command -v md5 &> /dev/null; then
            md5 -q "$file"
        else
            md5sum "$file" | cut -d' ' -f1
        fi
    else
        echo ""
    fi
}

install_context() {
    local review_path="$1"
    local context_dst="$review_path/context"

    # Create context directories
    mkdir -p "$context_dst/languages"
    mkdir -p "$context_dst/frameworks"
    mkdir -p "$context_dst/orgs"

    local updated=0
    local preserved=0
    local new=0

    # Copy language context files
    for src in "$SCRIPT_DIR/context/languages/"*.md; do
        [ -e "$src" ] || continue
        local filename=$(basename "$src")
        local dst="$context_dst/languages/$filename"

        if [ -f "$dst" ]; then
            local src_sum=$(get_file_checksum "$src")
            local dst_sum=$(get_file_checksum "$dst")

            if [ "$src_sum" != "$dst_sum" ]; then
                # File was modified by user, back it up
                cp "$dst" "$dst.bak"
                cp "$src" "$dst"
                warn "Updated (backed up modified): languages/$filename"
                preserved=$((preserved + 1))
            else
                # File unchanged, update silently
                cp "$src" "$dst"
                updated=$((updated + 1))
            fi
        else
            # New file
            cp "$src" "$dst"
            new=$((new + 1))
        fi
    done

    # Copy framework context files
    for src in "$SCRIPT_DIR/context/frameworks/"*.md; do
        [ -e "$src" ] || continue
        local filename=$(basename "$src")
        local dst="$context_dst/frameworks/$filename"

        if [ -f "$dst" ]; then
            local src_sum=$(get_file_checksum "$src")
            local dst_sum=$(get_file_checksum "$dst")

            if [ "$src_sum" != "$dst_sum" ]; then
                cp "$dst" "$dst.bak"
                cp "$src" "$dst"
                warn "Updated (backed up modified): frameworks/$filename"
                preserved=$((preserved + 1))
            else
                cp "$src" "$dst"
                updated=$((updated + 1))
            fi
        else
            cp "$src" "$dst"
            new=$((new + 1))
        fi
    done

    # Copy org context directories (recursive)
    if [ -d "$SCRIPT_DIR/context/orgs" ]; then
        for org_dir in "$SCRIPT_DIR/context/orgs/"*; do
            [ -d "$org_dir" ] || continue
            local org_name=$(basename "$org_dir")
            mkdir -p "$context_dst/orgs/$org_name"

            # Copy all files in org directory
            for src in "$org_dir"/*.md; do
                [ -e "$src" ] || continue
                local filename=$(basename "$src")
                local dst="$context_dst/orgs/$org_name/$filename"

                if [ -f "$dst" ]; then
                    local src_sum=$(get_file_checksum "$src")
                    local dst_sum=$(get_file_checksum "$dst")

                    if [ "$src_sum" != "$dst_sum" ]; then
                        cp "$dst" "$dst.bak"
                        cp "$src" "$dst"
                        warn "Updated (backed up modified): orgs/$org_name/$filename"
                        preserved=$((preserved + 1))
                    else
                        cp "$src" "$dst"
                        updated=$((updated + 1))
                    fi
                else
                    cp "$src" "$dst"
                    new=$((new + 1))
                fi
            done

            # Copy repo-specific context if exists
            if [ -d "$org_dir/repos" ]; then
                mkdir -p "$context_dst/orgs/$org_name/repos"
                for src in "$org_dir/repos/"*.md; do
                    [ -e "$src" ] || continue
                    local filename=$(basename "$src")
                    local dst="$context_dst/orgs/$org_name/repos/$filename"

                    if [ -f "$dst" ]; then
                        local src_sum=$(get_file_checksum "$src")
                        local dst_sum=$(get_file_checksum "$dst")

                        if [ "$src_sum" != "$dst_sum" ]; then
                            cp "$dst" "$dst.bak"
                            cp "$src" "$dst"
                            warn "Updated (backed up modified): orgs/$org_name/repos/$filename"
                            preserved=$((preserved + 1))
                        else
                            cp "$src" "$dst"
                            updated=$((updated + 1))
                        fi
                    else
                        cp "$src" "$dst"
                        new=$((new + 1))
                    fi
                done
            fi
        done
    fi

    info "Context files: $new new, $updated updated, $preserved preserved"
}

check_old_installation() {
    local old_dir="$HOME/.review-code"

    if [ -d "$old_dir" ]; then
        echo ""
        echo "═══════════════════════════════════════════════════════"
        warn "Old installation detected at $old_dir"
        echo "═══════════════════════════════════════════════════════"
        echo ""
        echo "The new installation method no longer uses this directory."
        echo "After installing, you can safely remove it."
        echo ""
        read -p "Remove old installation after new install completes? [Y/n] " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            return 0 # Will remove
        else
            return 1 # Will not remove
        fi
    fi

    return 2 # No old installation
}

cleanup_old_installation() {
    local old_dir="$HOME/.review-code"

    if [ -d "$old_dir" ]; then
        rm -rf "$old_dir"
        info "Removed old installation directory"
    fi

    # Remove old symlinks if they exist
    if [ -L "$CLAUDE_DIR/commands/review-code.md" ]; then
        rm "$CLAUDE_DIR/commands/review-code.md"
    fi

    for agent in "$CLAUDE_DIR/agents/code-reviewer-"*.md "$CLAUDE_DIR/agents/code-review-context-explorer.md"; do
        if [ -L "$agent" ]; then
            rm "$agent"
        fi
    done
}

check_permissions_configured() {
    local settings_file="$CLAUDE_DIR/settings.json"

    # If no settings file, permissions aren't configured
    if [ ! -f "$settings_file" ]; then
        return 1
    fi

    # Check if jq is available
    if ! command -v jq &> /dev/null; then
        return 1
    fi

    # Check if the key permission is already configured
    if jq -e '.permissions.allow | index("Bash(~/.claude/bin/review-code/*:*)")' "$settings_file" > /dev/null 2>&1; then
        return 0
    fi

    return 1
}

prompt_configure_permissions() {
    # Check if permissions are already configured
    if check_permissions_configured; then
        echo ""
        info "Permissions already configured - skipping prompt"
        return
    fi

    echo ""
    echo "═══════════════════════════════════════════════════════"
    echo "  Configure Claude Code Permissions (Optional)"
    echo "═══════════════════════════════════════════════════════"
    echo ""
    echo "Review-code needs permission to run helper scripts."
    echo ""
    echo "You can either:"
    echo "  1. Pre-authorize scripts now (recommended)"
    echo "  2. Approve each script when Claude Code asks"
    echo ""
    read -p "Pre-authorize review-code scripts? [Y/n] " -n 1 -r
    echo ""

    if [[ ! $REPLY =~ ^[Nn]$ ]]; then
        if [ -f "$SCRIPT_DIR/bin/manage-permissions" ]; then
            "$SCRIPT_DIR/bin/manage-permissions" add
        else
            warn "manage-permissions script not found"
            warn "You'll need to approve permissions when Claude Code asks"
        fi
    else
        echo ""
        info "Skipped automatic permission configuration"
        echo "  You'll be prompted to approve scripts when they run"
        echo "  To configure later, run: bin/manage-permissions add"
    fi
}

show_next_steps() {
    echo ""
    echo "═══════════════════════════════════════════════════════"
    echo "  Next Steps"
    echo "═══════════════════════════════════════════════════════"
    echo ""
    echo "Review-code uses helper scripts that need permission to run."
    echo ""
    echo "When Claude Code asks to run a script, you'll see:"
    echo "  • Script name (e.g., git-context.sh)"
    echo "  • What it does (e.g., Extract repo metadata)"
    echo ""
    echo "All scripts are READ-ONLY and only analyze your code."
    echo ""
    echo "Tip: Choose 'Always allow' to avoid repeated prompts."
    echo ""
}

main() {
    echo ""
    echo "═══════════════════════════════════════════════════════"
    echo "  Review-Code Local Installation"
    echo "═══════════════════════════════════════════════════════"
    echo ""

    # Check prerequisites
    info "Checking prerequisites…"
    check_prerequisites

    # Verify repository structure
    info "Verifying repository structure…"
    verify_repo_structure

    # Check for old installation (returns 0=remove, 1=keep, 2=none)
    set +e
    check_old_installation
    local remove_old=$?
    set -e

    # Get review path
    review_path=$(get_review_path)

    # Install components
    echo ""
    info "Installing review-code components…"
    create_config "$review_path"
    install_commands
    install_agents
    install_scripts
    install_context "$review_path"

    # Prompt for permission configuration
    prompt_configure_permissions

    # Cleanup old installation if requested
    if [ $remove_old -eq 0 ]; then
        echo ""
        cleanup_old_installation
    fi

    # Show next steps
    show_next_steps

    # Success summary
    echo ""
    echo "═══════════════════════════════════════════════════════"
    echo ""
    info "Installation complete!"
    echo ""
    echo "Review-code is now ready to use:"
    echo "  - Run: /review-code"
    echo "  - Review PR: /review-code <pr-number>"
    echo "  - Specific review: /review-code security"
    echo ""
    echo "Configure permissions:"
    echo "  - Add: bin/manage-permissions add"
    echo "  - Remove: bin/manage-permissions remove"
    echo "  - Status: bin/manage-permissions status"
    echo "  - Or approve individually when prompted"
    echo ""
    echo "Installation locations:"
    echo "  - Config: $CONFIG_FILE"
    echo "  - Commands: $CLAUDE_DIR/commands/"
    echo "  - Agents: $CLAUDE_DIR/agents/"
    echo "  - Scripts: $CLAUDE_DIR/bin/"
    echo "  - Context: $review_path/context/"
    echo "  - Reviews: $review_path/{org}/{repo}/"
    echo ""
    echo "To update: Run bin/setup again"
    echo "To uninstall: Run uninstall.sh"
    echo ""
    echo "═══════════════════════════════════════════════════════"
    echo ""
}

main "$@"
