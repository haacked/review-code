#!/usr/bin/env bash
# bin/setup - Install review-code from local repository
#
# Usage:
#   bin/setup
#
# Description:
#   Installs review-code by copying files from current directory to:
#   - ~/.claude/skills/review-code/ - Skill files (SKILL.md + scripts/ + context/ + reviews/)
#   - ~/.claude/agents/ - Agent files
#
#   Context files are installed with smart merge to preserve user learnings.
#   This script can be run repeatedly during development.
#
# Prerequisites:
#   - bash 4.0+
#   - git
#   - gh (GitHub CLI)
#   - jq
#   - ~/.claude directory

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Directories
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
CLAUDE_DIR="${HOME}/.claude"
SKILL_DIR="${CLAUDE_DIR}/skills/review-code"

# Functions
info() {
    echo -e "${GREEN}✓${NC} $1"
}

warn() {
    echo -e "${YELLOW}⚠${NC} $1"
}

error() {
    echo -e "${RED}✗${NC} $1"
}

debug() {
    echo -e "${BLUE}→${NC} $1"
}

check_prerequisites() {
    local missing=()

    # Check bash version
    if [[ "${BASH_VERSINFO[0]}" -lt 4 ]]; then
        missing+=("bash 4.0+")
    fi

    # Check required commands
    for cmd in git gh jq; do
        if ! command -v "${cmd}" &> /dev/null; then
            missing+=("${cmd}")
        fi
    done

    # Check ~/.claude directory
    if [[ ! -d "${CLAUDE_DIR}" ]]; then
        missing+=("${HOME}/.claude directory (install Claude Code first)")
    fi

    if [[ ${#missing[@]} -gt 0 ]]; then
        error "Missing prerequisites:"
        for item in "${missing[@]}"; do
            echo "  - ${item}"
        done
        echo ""
        echo "Install instructions:"
        echo "  - bash 4.0+: brew install bash"
        echo "  - git: brew install git"
        echo "  - gh: brew install gh"
        echo "  - jq: brew install jq"
        exit 1
    fi
}

verify_repo_structure() {
    local required_dirs=("skills/review-code" "skills/review-code/context" "agents")
    local missing=()

    for dir in "${required_dirs[@]}"; do
        if [[ ! -d "${SCRIPT_DIR}/${dir}" ]]; then
            missing+=("${dir}/")
        fi
    done

    if [[ ${#missing[@]} -gt 0 ]]; then
        error "Missing required directories:"
        for item in "${missing[@]}"; do
            echo "  - ${item}"
        done
        echo ""
        echo "Are you running this from the review-code repository root?"
        exit 1
    fi
}

install_skill() {
    local src_dir="${SCRIPT_DIR}/skills/review-code"
    local dst_dir="${SKILL_DIR}"

    # Create skill directory structure
    mkdir -p "${dst_dir}/scripts/helpers"
    mkdir -p "${dst_dir}/reviews"
    mkdir -p "${dst_dir}/learnings"

    # Copy SKILL.md
    local skill_src="${src_dir}/SKILL.md"
    local skill_dst="${dst_dir}/SKILL.md"

    if [[ -f "${skill_dst}" ]] && [[ ! -L "${skill_dst}" ]]; then
        debug "Backing up existing SKILL.md"
        cp "${skill_dst}" "${skill_dst}.bak"
    fi

    if [[ -L "${skill_dst}" ]]; then
        rm "${skill_dst}"
    fi

    cp "${skill_src}" "${skill_dst}"

    # Copy scripts
    local script_count=0
    for src in "${src_dir}/scripts/"*.sh; do
        [[ -e "${src}" ]] || continue
        local filename
        filename=$(basename "${src}")
        local dst="${dst_dir}/scripts/${filename}"

        cp "${src}" "${dst}"
        chmod +x "${dst}"
        script_count=$((script_count + 1))
    done

    # Copy helper scripts
    if [[ -d "${src_dir}/scripts/helpers" ]]; then
        for src in "${src_dir}/scripts/helpers/"*.sh; do
            [[ -e "${src}" ]] || continue
            local filename
            filename=$(basename "${src}")
            local dst="${dst_dir}/scripts/helpers/${filename}"

            cp "${src}" "${dst}"
            chmod +x "${dst}"
        done
    fi

    # Copy learnings README if not exists
    if [[ -f "${src_dir}/learnings/README.md" ]] && [[ ! -f "${dst_dir}/learnings/README.md" ]]; then
        cp "${src_dir}/learnings/README.md" "${dst_dir}/learnings/README.md"
    fi

    # Copy uninstall script to main bin (not in skill folder)
    if [[ -f "${SCRIPT_DIR}/uninstall.sh" ]]; then
        mkdir -p "${CLAUDE_DIR}/bin"
        cp "${SCRIPT_DIR}/uninstall.sh" "${CLAUDE_DIR}/bin/uninstall-review-code.sh"
        chmod +x "${CLAUDE_DIR}/bin/uninstall-review-code.sh"
    fi

    info "Installed skill: review-code (${script_count} scripts)"
}

install_agents() {
    local agents=(
        "code-review-context-explorer"
        "code-reviewer-security"
        "code-reviewer-performance"
        "code-reviewer-correctness"
        "code-reviewer-maintainability"
        "code-reviewer-testing"
        "code-reviewer-compatibility"
        "code-reviewer-architecture"
        "code-reviewer-frontend"
    )

    # Create agents directory
    mkdir -p "${CLAUDE_DIR}/agents"

    for agent in "${agents[@]}"; do
        local src="${SCRIPT_DIR}/agents/${agent}.md"
        local dst="${CLAUDE_DIR}/agents/${agent}.md"

        # Backup existing file if not a symlink
        if [[ -f "${dst}" ]] && [[ ! -L "${dst}" ]]; then
            cp "${dst}" "${dst}.bak"
        fi

        # Remove old symlink if exists
        if [[ -L "${dst}" ]]; then
            rm "${dst}"
        fi

        # Copy file
        cp "${src}" "${dst}"
    done

    info "Installed ${#agents[@]} agents (8 reviewers + 1 context explorer)"
}

cleanup_old_command() {
    # Remove old command-based installation if it exists
    local old_command="${CLAUDE_DIR}/commands/review-code.md"
    local old_scripts="${CLAUDE_DIR}/bin/review-code"

    if [[ -f "${old_command}" ]] || [[ -d "${old_scripts}" ]]; then
        debug "Cleaning up old command-based installation…"

        if [[ -f "${old_command}" ]]; then
            rm -f "${old_command}"
        fi

        if [[ -d "${old_scripts}" ]]; then
            rm -rf "${old_scripts}"
        fi

        info "Removed old command installation"
    fi
}

get_file_checksum() {
    local file="$1"
    if [[ -f "${file}" ]]; then
        # Use md5 on macOS, md5sum on Linux
        if command -v md5 &> /dev/null; then
            md5 -q "${file}"
        else
            md5sum "${file}" | cut -d' ' -f1
        fi
    else
        echo ""
    fi
}

# Extract section headers from a markdown file
# Returns one header per line (without the ## prefix)
get_section_headers() {
    local file="$1"
    grep -E '^## ' "${file}" 2> /dev/null | sed 's/^## //' || true
}

# Check if a section header exists in a file
has_section() {
    local file="$1"
    local section="$2"
    grep -qE "^## ${section}$" "${file}" 2> /dev/null
}

# Extract a section from a markdown file (header + content until next header or EOF)
extract_section() {
    local file="$1"
    local section="$2"

    # Use awk to extract the section
    awk -v section="$section" '
        /^## / {
            if ($0 == "## " section) {
                printing = 1
            } else if (printing) {
                exit
            }
        }
        printing { print }
    ' "${file}"
}

# Smart merge: copy new sections from src to dst, preserving existing dst content
merge_markdown_sections() {
    local src="$1"
    local dst="$2"

    # Get sections from source that don't exist in destination
    local new_sections_added=0
    while IFS= read -r section; do
        [[ -z "${section}" ]] && continue

        if ! has_section "${dst}" "${section}"; then
            # Section doesn't exist in destination - append it
            local section_content
            section_content=$(extract_section "${src}" "${section}")

            if [[ -n "${section_content}" ]]; then
                echo "" >> "${dst}"
                echo "${section_content}" >> "${dst}"
                new_sections_added=$((new_sections_added + 1))
            fi
        fi
    done < <(get_section_headers "${src}")

    echo "${new_sections_added}"
}

install_context() {
    local context_src="${SCRIPT_DIR}/skills/review-code/context"
    local context_dst="${SKILL_DIR}/context"

    # Create context directories
    mkdir -p "${context_dst}/languages"
    mkdir -p "${context_dst}/frameworks"
    mkdir -p "${context_dst}/orgs"

    local updated=0
    local preserved=0
    local new=0
    local merged=0

    # Copy language context files with smart merge
    for src in "${context_src}/languages/"*.md; do
        [[ -e "${src}" ]] || continue
        local filename
        filename=$(basename "${src}")
        local dst="${context_dst}/languages/${filename}"

        if [[ -f "${dst}" ]]; then
            local src_sum dst_sum
            src_sum=$(get_file_checksum "${src}")
            dst_sum=$(get_file_checksum "${dst}")

            if [[ "${src_sum}" != "${dst_sum}" ]]; then
                # Files differ - try smart merge
                local sections_added
                sections_added=$(merge_markdown_sections "${src}" "${dst}")

                if [[ "${sections_added}" -gt 0 ]]; then
                    debug "Merged ${sections_added} new section(s): languages/${filename}"
                    merged=$((merged + 1))
                else
                    # No new sections to add, preserve user's version
                    preserved=$((preserved + 1))
                fi
            else
                # Files identical, just update
                cp "${src}" "${dst}"
                updated=$((updated + 1))
            fi
        else
            # New file
            cp "${src}" "${dst}"
            new=$((new + 1))
        fi
    done

    # Copy framework context files with smart merge
    for src in "${context_src}/frameworks/"*.md; do
        [[ -e "${src}" ]] || continue
        local filename
        filename=$(basename "${src}")
        local dst="${context_dst}/frameworks/${filename}"

        if [[ -f "${dst}" ]]; then
            local src_sum dst_sum
            src_sum=$(get_file_checksum "${src}")
            dst_sum=$(get_file_checksum "${dst}")

            if [[ "${src_sum}" != "${dst_sum}" ]]; then
                local sections_added
                sections_added=$(merge_markdown_sections "${src}" "${dst}")

                if [[ "${sections_added}" -gt 0 ]]; then
                    debug "Merged ${sections_added} new section(s): frameworks/${filename}"
                    merged=$((merged + 1))
                else
                    preserved=$((preserved + 1))
                fi
            else
                cp "${src}" "${dst}"
                updated=$((updated + 1))
            fi
        else
            cp "${src}" "${dst}"
            new=$((new + 1))
        fi
    done

    # Copy org context directories (recursive) - these are less likely to have user edits
    if [[ -d "${context_src}/orgs" ]]; then
        for org_dir in "${context_src}/orgs/"*; do
            [[ -d "${org_dir}" ]] || continue
            local org_name
            org_name=$(basename "${org_dir}")
            mkdir -p "${context_dst}/orgs/${org_name}"

            # Copy all files in org directory
            for src in "${org_dir}"/*.md; do
                [[ -e "${src}" ]] || continue
                local filename
                filename=$(basename "${src}")
                local dst="${context_dst}/orgs/${org_name}/${filename}"

                if [[ -f "${dst}" ]]; then
                    local src_sum dst_sum
                    src_sum=$(get_file_checksum "${src}")
                    dst_sum=$(get_file_checksum "${dst}")

                    if [[ "${src_sum}" != "${dst_sum}" ]]; then
                        local sections_added
                        sections_added=$(merge_markdown_sections "${src}" "${dst}")

                        if [[ "${sections_added}" -gt 0 ]]; then
                            debug "Merged ${sections_added} new section(s): orgs/${org_name}/${filename}"
                            merged=$((merged + 1))
                        else
                            preserved=$((preserved + 1))
                        fi
                    else
                        cp "${src}" "${dst}"
                        updated=$((updated + 1))
                    fi
                else
                    cp "${src}" "${dst}"
                    new=$((new + 1))
                fi
            done

            # Copy repo-specific context if exists
            if [[ -d "${org_dir}/repos" ]]; then
                mkdir -p "${context_dst}/orgs/${org_name}/repos"
                for src in "${org_dir}/repos/"*.md; do
                    [[ -e "${src}" ]] || continue
                    local filename
                    filename=$(basename "${src}")
                    local dst="${context_dst}/orgs/${org_name}/repos/${filename}"

                    if [[ -f "${dst}" ]]; then
                        local src_sum dst_sum
                        src_sum=$(get_file_checksum "${src}")
                        dst_sum=$(get_file_checksum "${dst}")

                        if [[ "${src_sum}" != "${dst_sum}" ]]; then
                            local sections_added
                            sections_added=$(merge_markdown_sections "${src}" "${dst}")

                            if [[ "${sections_added}" -gt 0 ]]; then
                                debug "Merged ${sections_added} new section(s): orgs/${org_name}/repos/${filename}"
                                merged=$((merged + 1))
                            else
                                preserved=$((preserved + 1))
                            fi
                        else
                            cp "${src}" "${dst}"
                            updated=$((updated + 1))
                        fi
                    else
                        cp "${src}" "${dst}"
                        new=$((new + 1))
                    fi
                done
            fi
        done
    fi

    local summary="${new} new"
    if [[ ${updated} -gt 0 ]]; then
        summary="${summary}, ${updated} updated"
    fi
    if [[ ${merged} -gt 0 ]]; then
        summary="${summary}, ${merged} merged"
    fi
    if [[ ${preserved} -gt 0 ]]; then
        summary="${summary}, ${preserved} preserved"
    fi
    info "Context files: ${summary}"
}

cleanup_old_config() {
    # Remove old config files that are no longer needed
    local old_config_files=(
        "${SKILL_DIR}/.env"
        "${CLAUDE_DIR}/review-code.env"
    )

    for config_file in "${old_config_files[@]}"; do
        if [[ -f "${config_file}" ]]; then
            debug "Removing deprecated config: ${config_file}"
            rm -f "${config_file}"
        fi
    done
}

check_old_installation() {
    local old_dir="${HOME}/.review-code"

    if [[ -d "${old_dir}" ]]; then
        echo ""
        echo "═══════════════════════════════════════════════════════"
        warn "Old installation detected at ${old_dir}"
        echo "═══════════════════════════════════════════════════════"
        echo ""
        echo "The new installation method no longer uses this directory."
        echo "After installing, you can safely remove it."
        echo ""
        read -p "Remove old installation after new install completes? [Y/n] " -n 1 -r
        echo ""
        if [[ ! ${REPLY} =~ ^[Nn]$ ]]; then
            return 0 # Will remove
        else
            return 1 # Will not remove
        fi
    fi

    return 2 # No old installation
}

cleanup_old_installation() {
    local old_dir="${HOME}/.review-code"

    if [[ -d "${old_dir}" ]]; then
        rm -rf "${old_dir}"
        info "Removed old installation directory"
    fi

    # Remove old symlinks if they exist
    if [[ -L "${CLAUDE_DIR}/commands/review-code.md" ]]; then
        rm "${CLAUDE_DIR}/commands/review-code.md"
    fi

    for agent in "${CLAUDE_DIR}/agents/code-reviewer-"*.md "${CLAUDE_DIR}/agents/code-review-context-explorer.md"; do
        if [[ -L "${agent}" ]]; then
            rm "${agent}"
        fi
    done
}

check_permissions_configured() {
    local settings_file="${CLAUDE_DIR}/settings.json"

    # If no settings file, permissions aren't configured
    if [[ ! -f "${settings_file}" ]]; then
        return 1
    fi

    # Check if jq is available
    if ! command -v jq &> /dev/null; then
        return 1
    fi

    # Check if the key permission is already configured (check both old and new paths)
    if jq -e '.permissions.allow | index("Bash(~/.claude/skills/review-code/scripts/*:*)")' "${settings_file}" > /dev/null 2>&1; then
        return 0
    fi

    # Also check old path pattern for backwards compatibility
    if jq -e '.permissions.allow | index("Bash(~/.claude/bin/review-code/*:*)")' "${settings_file}" > /dev/null 2>&1; then
        return 0
    fi

    return 1
}

prompt_configure_permissions() {
    # Check if permissions are already configured
    # shellcheck disable=SC2310  # Intentional conditional check
    if check_permissions_configured; then
        echo ""
        info "Permissions already configured - skipping prompt"
        return
    fi

    echo ""
    echo "═══════════════════════════════════════════════════════"
    echo "  Configure Claude Code Permissions (Optional)"
    echo "═══════════════════════════════════════════════════════"
    echo ""
    echo "Review-code needs permission to run helper scripts."
    echo ""
    echo "You can either:"
    echo "  1. Pre-authorize scripts now (recommended)"
    echo "  2. Approve each script when Claude Code asks"
    echo ""
    read -p "Pre-authorize review-code scripts? [Y/n] " -n 1 -r
    echo ""

    if [[ ! ${REPLY} =~ ^[Nn]$ ]]; then
        if [[ -f "${SCRIPT_DIR}/bin/manage-permissions" ]]; then
            "${SCRIPT_DIR}/bin/manage-permissions" add
        else
            warn "manage-permissions script not found"
            warn "You'll need to approve permissions when Claude Code asks"
        fi
    else
        echo ""
        info "Skipped automatic permission configuration"
        echo "  You'll be prompted to approve scripts when they run"
        echo "  To configure later, run: bin/manage-permissions add"
    fi
}

show_next_steps() {
    echo ""
    echo "═══════════════════════════════════════════════════════"
    echo "  Next Steps"
    echo "═══════════════════════════════════════════════════════"
    echo ""
    echo "Review-code uses helper scripts that need permission to run."
    echo ""
    echo "When Claude Code asks to run a script, you'll see:"
    echo "  • Script name (e.g., git-context.sh)"
    echo "  • What it does (e.g., Extract repo metadata)"
    echo ""
    echo "All scripts are READ-ONLY and only analyze your code."
    echo ""
    echo "Tip: Choose 'Always allow' to avoid repeated prompts."
    echo ""
}

main() {
    echo ""
    echo "═══════════════════════════════════════════════════════"
    echo "  Review-Code Local Installation"
    echo "═══════════════════════════════════════════════════════"
    echo ""

    # Check prerequisites
    info "Checking prerequisites…"
    check_prerequisites

    # Verify repository structure
    info "Verifying repository structure…"
    verify_repo_structure

    # Check for old installation (returns 0=remove, 1=keep, 2=none)
    set +e
    check_old_installation
    local remove_old=$?
    set -e

    # Cleanup old command-based installation if exists
    cleanup_old_command

    # Clean up deprecated config files
    cleanup_old_config

    # Install components
    echo ""
    info "Installing review-code components…"
    install_skill
    install_agents
    install_context

    # Prompt for permission configuration
    prompt_configure_permissions

    # Cleanup old installation if requested
    if [[ "${remove_old}" -eq 0 ]]; then
        echo ""
        cleanup_old_installation
    fi

    # Show next steps
    show_next_steps

    # Success summary
    echo ""
    echo "═══════════════════════════════════════════════════════"
    echo ""
    info "Installation complete!"
    echo ""
    echo "Review-code is now ready to use:"
    echo "  - Run: /review-code"
    echo "  - Review PR: /review-code <pr-number>"
    echo "  - Specific review: /review-code security"
    echo ""
    echo "Configure permissions:"
    echo "  - Add: bin/manage-permissions add"
    echo "  - Remove: bin/manage-permissions remove"
    echo "  - Status: bin/manage-permissions status"
    echo "  - Or approve individually when prompted"
    echo ""
    echo "Installation locations:"
    echo "  - Skill: ${SKILL_DIR}/"
    echo "  - Agents: ${CLAUDE_DIR}/agents/"
    echo "  - Context: ${SKILL_DIR}/context/"
    echo "  - Reviews: ${SKILL_DIR}/reviews/"
    echo ""
    echo "To update: Run bin/setup again"
    echo "To uninstall: Run uninstall.sh"
    echo ""
    echo "═══════════════════════════════════════════════════════"
    echo ""
}

main "$@"
