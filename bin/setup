#!/usr/bin/env bash
# bin/setup - Install review-code from local repository
#
# Usage:
#   bin/setup
#
# Description:
#   Installs review-code by copying files from current directory to:
#   - ~/.claude/skills/review-code/ - Skill files (SKILL.md + scripts/)
#   - ~/.claude/agents/ - Agent files
#   - {REVIEW_PATH}/context/ - Context files (preserves user edits)
#
#   This script can be run repeatedly during development.
#
# Prerequisites:
#   - bash 4.0+
#   - git
#   - gh (GitHub CLI)
#   - jq
#   - ~/.claude directory

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Directories
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
CLAUDE_DIR="${HOME}/.claude"
SKILL_DIR="${CLAUDE_DIR}/skills/review-code"
CONFIG_FILE="${SKILL_DIR}/.env"
OLD_CONFIG_FILE="${CLAUDE_DIR}/review-code.env" # For migration
DEFAULT_REVIEW_PATH="${HOME}/dev/ai/reviews"

# Functions
info() {
    echo -e "${GREEN}✓${NC} $1"
}

warn() {
    echo -e "${YELLOW}⚠${NC} $1"
}

error() {
    echo -e "${RED}✗${NC} $1"
}

debug() {
    echo -e "${BLUE}→${NC} $1"
}

check_prerequisites() {
    local missing=()

    # Check bash version
    if [[ "${BASH_VERSINFO[0]}" -lt 4 ]]; then
        missing+=("bash 4.0+")
    fi

    # Check required commands
    for cmd in git gh jq; do
        if ! command -v "${cmd}" &> /dev/null; then
            missing+=("${cmd}")
        fi
    done

    # Check ~/.claude directory
    if [[ ! -d "${CLAUDE_DIR}" ]]; then
        missing+=("${HOME}/.claude directory (install Claude Code first)")
    fi

    if [[ ${#missing[@]} -gt 0 ]]; then
        error "Missing prerequisites:"
        for item in "${missing[@]}"; do
            echo "  - ${item}"
        done
        echo ""
        echo "Install instructions:"
        echo "  - bash 4.0+: brew install bash"
        echo "  - git: brew install git"
        echo "  - gh: brew install gh"
        echo "  - jq: brew install jq"
        exit 1
    fi
}

verify_repo_structure() {
    local required_dirs=("skills/review-code" "agents" "context")
    local missing=()

    for dir in "${required_dirs[@]}"; do
        if [[ ! -d "${SCRIPT_DIR}/${dir}" ]]; then
            missing+=("${dir}/")
        fi
    done

    if [[ ${#missing[@]} -gt 0 ]]; then
        error "Missing required directories:"
        for item in "${missing[@]}"; do
            echo "  - ${item}"
        done
        echo ""
        echo "Are you running this from the review-code repository root?"
        exit 1
    fi
}

# Safely load configuration from file without executing arbitrary code
load_config_safely() {
    local config_file="$1"

    [[ ! -f "${config_file}" ]] && return 0

    # Validate file permissions for security
    local file_owner
    local file_perms

    if [[ "${OSTYPE}" == "darwin"* ]]; then
        file_owner=$(stat -f '%u' "${config_file}" 2> /dev/null)
        file_perms=$(stat -f '%Lp' "${config_file}" 2> /dev/null)
    else
        file_owner=$(stat -c '%u' "${config_file}" 2> /dev/null)
        file_perms=$(stat -c '%a' "${config_file}" 2> /dev/null)
    fi

    # shellcheck disable=SC2312  # id command failure is critical and will be caught
    if [[ "${file_owner}" != "$(id -u)" ]]; then
        error "Config file not owned by current user: ${config_file}"
        return 1
    fi

    local world_perms=$((file_perms % 10))
    if [[ $((world_perms & 2)) -ne 0 ]]; then
        error "Config file is world-writable: ${config_file}"
        error "Fix with: chmod o-w ${config_file}"
        return 1
    fi

    # Parse configuration safely
    while IFS='=' read -r key value; do
        [[ "${key}" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${key}" ]] && continue
        [[ ! "${key}" =~ ^[A-Z_][A-Z0-9_]*$ ]] && continue

        value="${value#\"}"
        value="${value%\"}"
        value="${value#\'}"
        value="${value%\'}"

        case "${key}" in
            REVIEW_ROOT_PATH) export REVIEW_ROOT_PATH="${value}" ;;
            CONTEXT_PATH) export CONTEXT_PATH="${value}" ;;
            DIFF_CONTEXT_LINES) export DIFF_CONTEXT_LINES="${value}" ;;
            CACHE_TTL_HOURS) export CACHE_TTL_HOURS="${value}" ;;
            *) ;; # Ignore unknown keys for forward compatibility
        esac
    done < "${config_file}"

    return 0
}

get_review_path() {
    local review_path=""

    # Check if config already exists
    if [[ -f "${CONFIG_FILE}" ]]; then
        load_config_safely "${CONFIG_FILE}"
        review_path="${REVIEW_ROOT_PATH:-}"
        if [[ -n "${review_path}" ]]; then
            # If path exists and is writable, use it without prompting
            # Expand tilde if present
            local expanded_path="${review_path/#\~/${HOME}}"
            if [[ -d "${expanded_path}" ]] && [[ -w "${expanded_path}" ]]; then
                info "Using existing review path: ${review_path}" >&2
                echo "${review_path}"
                return
            fi

            # Path in config is invalid, prompt user
            echo "" >&2
            warn "Configured path doesn't exist or isn't writable: ${review_path}"
            read -p "Enter a new path? [Y/n] " -n 1 -r
            echo "" >&2
            if [[ ${REPLY} =~ ^[Nn]$ ]]; then
                error "Installation cancelled"
                exit 1
            fi
        fi
    fi

    # Prompt for new path
    echo "" >&2
    echo "Where should code reviews and context files be saved?" >&2
    read -r -p "Review path [${DEFAULT_REVIEW_PATH}]: " review_path
    review_path="${review_path:-${DEFAULT_REVIEW_PATH}}"

    # Expand tilde
    review_path="${review_path/#\~/${HOME}}"

    # Validate and create directory
    if [[ ! -d "${review_path}" ]]; then
        read -p "Directory doesn't exist. Create it? [Y/n] " -n 1 -r
        echo "" >&2
        if [[ ! ${REPLY} =~ ^[Nn]$ ]]; then
            mkdir -p "${review_path}"
            info "Created directory: ${review_path}"
        else
            error "Installation cancelled"
            exit 1
        fi
    fi

    # Check if writable
    if [[ ! -w "${review_path}" ]]; then
        error "Directory is not writable: ${review_path}"
        exit 1
    fi

    echo "${review_path}"
}

migrate_old_config() {
    # Migrate config from old location to new location
    if [[ -f "${OLD_CONFIG_FILE}" ]] && [[ ! -f "${CONFIG_FILE}" ]]; then
        # Ensure skill directory exists
        mkdir -p "${SKILL_DIR}"
        mv "${OLD_CONFIG_FILE}" "${CONFIG_FILE}"
        info "Migrated config from ${OLD_CONFIG_FILE} to ${CONFIG_FILE}"
    elif [[ -f "${OLD_CONFIG_FILE}" ]] && [[ -f "${CONFIG_FILE}" ]]; then
        # Both exist - remove old one if they're the same, warn if different
        if diff -q "${OLD_CONFIG_FILE}" "${CONFIG_FILE}" > /dev/null 2>&1; then
            rm "${OLD_CONFIG_FILE}"
            debug "Removed duplicate old config file"
        else
            warn "Both old and new config files exist with different content"
            warn "Old: ${OLD_CONFIG_FILE}"
            warn "New: ${CONFIG_FILE}"
            warn "Please manually reconcile and remove the old file"
        fi
    fi
}

create_config() {
    local review_path="$1"
    local context_path="${review_path}/context"

    # Ensure skill directory exists
    mkdir -p "${SKILL_DIR}"

    # Write config file
    cat > "${CONFIG_FILE}" << EOF
# Claude Code review-code skill configuration
# Generated by bin/setup
#
# Root directory where code reviews are saved
# Reviews are organized as: {REVIEW_ROOT_PATH}/{org}/{repo}/{pr-number-or-branch}.md
REVIEW_ROOT_PATH="${review_path}"

# Directory where context files are stored (language/framework/org-specific guidelines)
# These files can be customized by users
CONTEXT_PATH="${context_path}"
EOF

    info "Configuration saved to: ${CONFIG_FILE}"
}

install_skill() {
    local src_dir="${SCRIPT_DIR}/skills/review-code"
    local dst_dir="${CLAUDE_DIR}/skills/review-code"

    # Create skill directory structure
    mkdir -p "${dst_dir}/scripts/helpers"

    # Copy SKILL.md
    local skill_src="${src_dir}/SKILL.md"
    local skill_dst="${dst_dir}/SKILL.md"

    if [[ -f "${skill_dst}" ]] && [[ ! -L "${skill_dst}" ]]; then
        debug "Backing up existing SKILL.md"
        cp "${skill_dst}" "${skill_dst}.bak"
    fi

    if [[ -L "${skill_dst}" ]]; then
        rm "${skill_dst}"
    fi

    cp "${skill_src}" "${skill_dst}"

    # Copy scripts
    local script_count=0
    for src in "${src_dir}/scripts/"*.sh; do
        [[ -e "${src}" ]] || continue
        local filename
        filename=$(basename "${src}")
        local dst="${dst_dir}/scripts/${filename}"

        cp "${src}" "${dst}"
        chmod +x "${dst}"
        script_count=$((script_count + 1))
    done

    # Copy helper scripts
    if [[ -d "${src_dir}/scripts/helpers" ]]; then
        for src in "${src_dir}/scripts/helpers/"*.sh; do
            [[ -e "${src}" ]] || continue
            local filename
            filename=$(basename "${src}")
            local dst="${dst_dir}/scripts/helpers/${filename}"

            cp "${src}" "${dst}"
            chmod +x "${dst}"
        done
    fi

    # Copy uninstall script to main bin (not in skill folder)
    if [[ -f "${SCRIPT_DIR}/uninstall.sh" ]]; then
        mkdir -p "${CLAUDE_DIR}/bin"
        cp "${SCRIPT_DIR}/uninstall.sh" "${CLAUDE_DIR}/bin/uninstall-review-code.sh"
        chmod +x "${CLAUDE_DIR}/bin/uninstall-review-code.sh"
    fi

    info "Installed skill: review-code (${script_count} scripts)"
}

install_agents() {
    local agents=(
        "code-review-context-explorer"
        "code-reviewer-security"
        "code-reviewer-performance"
        "code-reviewer-correctness"
        "code-reviewer-maintainability"
        "code-reviewer-testing"
        "code-reviewer-compatibility"
        "code-reviewer-architecture"
        "code-reviewer-frontend"
    )

    # Create agents directory
    mkdir -p "${CLAUDE_DIR}/agents"

    for agent in "${agents[@]}"; do
        local src="${SCRIPT_DIR}/agents/${agent}.md"
        local dst="${CLAUDE_DIR}/agents/${agent}.md"

        # Backup existing file if not a symlink
        if [[ -f "${dst}" ]] && [[ ! -L "${dst}" ]]; then
            cp "${dst}" "${dst}.bak"
        fi

        # Remove old symlink if exists
        if [[ -L "${dst}" ]]; then
            rm "${dst}"
        fi

        # Copy file
        cp "${src}" "${dst}"
    done

    info "Installed ${#agents[@]} agents (8 reviewers + 1 context explorer)"
}

cleanup_old_command() {
    # Remove old command-based installation if it exists
    local old_command="${CLAUDE_DIR}/commands/review-code.md"
    local old_scripts="${CLAUDE_DIR}/bin/review-code"

    if [[ -f "${old_command}" ]] || [[ -d "${old_scripts}" ]]; then
        debug "Cleaning up old command-based installation…"

        if [[ -f "${old_command}" ]]; then
            rm -f "${old_command}"
        fi

        if [[ -d "${old_scripts}" ]]; then
            rm -rf "${old_scripts}"
        fi

        info "Removed old command installation"
    fi
}

get_file_checksum() {
    local file="$1"
    if [[ -f "${file}" ]]; then
        # Use md5 on macOS, md5sum on Linux
        if command -v md5 &> /dev/null; then
            md5 -q "${file}"
        else
            md5sum "${file}" | cut -d' ' -f1
        fi
    else
        echo ""
    fi
}

install_context() {
    local review_path="$1"
    local context_dst="${review_path}/context"

    # Create context directories
    mkdir -p "${context_dst}/languages"
    mkdir -p "${context_dst}/frameworks"
    mkdir -p "${context_dst}/orgs"

    local updated=0
    local preserved=0
    local new=0

    # Copy language context files
    for src in "${SCRIPT_DIR}/context/languages/"*.md; do
        [[ -e "${src}" ]] || continue
        local filename
        filename=$(basename "${src}")
        local dst="${context_dst}/languages/${filename}"

        if [[ -f "${dst}" ]]; then
            local src_sum
            local dst_sum
            src_sum=$(get_file_checksum "${src}")
            dst_sum=$(get_file_checksum "${dst}")

            if [[ "${src_sum}" != "${dst_sum}" ]]; then
                # File was modified by user, back it up
                cp "${dst}" "${dst}.bak"
                cp "${src}" "${dst}"
                warn "Updated (backed up modified): languages/${filename}"
                preserved=$((preserved + 1))
            else
                # File unchanged, update silently
                cp "${src}" "${dst}"
                updated=$((updated + 1))
            fi
        else
            # New file
            cp "${src}" "${dst}"
            new=$((new + 1))
        fi
    done

    # Copy framework context files
    for src in "${SCRIPT_DIR}/context/frameworks/"*.md; do
        [[ -e "${src}" ]] || continue
        local filename
        filename=$(basename "${src}")
        local dst="${context_dst}/frameworks/${filename}"

        if [[ -f "${dst}" ]]; then
            local src_sum
            local dst_sum
            src_sum=$(get_file_checksum "${src}")
            dst_sum=$(get_file_checksum "${dst}")

            if [[ "${src_sum}" != "${dst_sum}" ]]; then
                cp "${dst}" "${dst}.bak"
                cp "${src}" "${dst}"
                warn "Updated (backed up modified): frameworks/${filename}"
                preserved=$((preserved + 1))
            else
                cp "${src}" "${dst}"
                updated=$((updated + 1))
            fi
        else
            cp "${src}" "${dst}"
            new=$((new + 1))
        fi
    done

    # Copy org context directories (recursive)
    if [[ -d "${SCRIPT_DIR}/context/orgs" ]]; then
        for org_dir in "${SCRIPT_DIR}/context/orgs/"*; do
            [[ -d "${org_dir}" ]] || continue
            local org_name
            org_name=$(basename "${org_dir}")
            mkdir -p "${context_dst}/orgs/${org_name}"

            # Copy all files in org directory
            for src in "${org_dir}"/*.md; do
                [[ -e "${src}" ]] || continue
                local filename
                filename=$(basename "${src}")
                local dst="${context_dst}/orgs/${org_name}/${filename}"

                if [[ -f "${dst}" ]]; then
                    local src_sum
                    local dst_sum
                    src_sum=$(get_file_checksum "${src}")
                    dst_sum=$(get_file_checksum "${dst}")

                    if [[ "${src_sum}" != "${dst_sum}" ]]; then
                        cp "${dst}" "${dst}.bak"
                        cp "${src}" "${dst}"
                        warn "Updated (backed up modified): orgs/${org_name}/${filename}"
                        preserved=$((preserved + 1))
                    else
                        cp "${src}" "${dst}"
                        updated=$((updated + 1))
                    fi
                else
                    cp "${src}" "${dst}"
                    new=$((new + 1))
                fi
            done

            # Copy repo-specific context if exists
            if [[ -d "${org_dir}/repos" ]]; then
                mkdir -p "${context_dst}/orgs/${org_name}/repos"
                for src in "${org_dir}/repos/"*.md; do
                    [[ -e "${src}" ]] || continue
                    local filename
                    filename=$(basename "${src}")
                    local dst="${context_dst}/orgs/${org_name}/repos/${filename}"

                    if [[ -f "${dst}" ]]; then
                        local src_sum
                        local dst_sum
                        src_sum=$(get_file_checksum "${src}")
                        dst_sum=$(get_file_checksum "${dst}")

                        if [[ "${src_sum}" != "${dst_sum}" ]]; then
                            cp "${dst}" "${dst}.bak"
                            cp "${src}" "${dst}"
                            warn "Updated (backed up modified): orgs/${org_name}/repos/${filename}"
                            preserved=$((preserved + 1))
                        else
                            cp "${src}" "${dst}"
                            updated=$((updated + 1))
                        fi
                    else
                        cp "${src}" "${dst}"
                        new=$((new + 1))
                    fi
                done
            fi
        done
    fi

    info "Context files: ${new} new, ${updated} updated, ${preserved} preserved"
}

check_old_installation() {
    local old_dir="${HOME}/.review-code"

    if [[ -d "${old_dir}" ]]; then
        echo ""
        echo "═══════════════════════════════════════════════════════"
        warn "Old installation detected at ${old_dir}"
        echo "═══════════════════════════════════════════════════════"
        echo ""
        echo "The new installation method no longer uses this directory."
        echo "After installing, you can safely remove it."
        echo ""
        read -p "Remove old installation after new install completes? [Y/n] " -n 1 -r
        echo ""
        if [[ ! ${REPLY} =~ ^[Nn]$ ]]; then
            return 0 # Will remove
        else
            return 1 # Will not remove
        fi
    fi

    return 2 # No old installation
}

cleanup_old_installation() {
    local old_dir="${HOME}/.review-code"

    if [[ -d "${old_dir}" ]]; then
        rm -rf "${old_dir}"
        info "Removed old installation directory"
    fi

    # Remove old symlinks if they exist
    if [[ -L "${CLAUDE_DIR}/commands/review-code.md" ]]; then
        rm "${CLAUDE_DIR}/commands/review-code.md"
    fi

    for agent in "${CLAUDE_DIR}/agents/code-reviewer-"*.md "${CLAUDE_DIR}/agents/code-review-context-explorer.md"; do
        if [[ -L "${agent}" ]]; then
            rm "${agent}"
        fi
    done
}

check_permissions_configured() {
    local settings_file="${CLAUDE_DIR}/settings.json"

    # If no settings file, permissions aren't configured
    if [[ ! -f "${settings_file}" ]]; then
        return 1
    fi

    # Check if jq is available
    if ! command -v jq &> /dev/null; then
        return 1
    fi

    # Check if the key permission is already configured (check both old and new paths)
    if jq -e '.permissions.allow | index("Bash(~/.claude/skills/review-code/scripts/*:*)")' "${settings_file}" > /dev/null 2>&1; then
        return 0
    fi

    # Also check old path pattern for backwards compatibility
    if jq -e '.permissions.allow | index("Bash(~/.claude/bin/review-code/*:*)")' "${settings_file}" > /dev/null 2>&1; then
        return 0
    fi

    return 1
}

prompt_configure_permissions() {
    # Check if permissions are already configured
    # shellcheck disable=SC2310  # Intentional conditional check
    if check_permissions_configured; then
        echo ""
        info "Permissions already configured - skipping prompt"
        return
    fi

    echo ""
    echo "═══════════════════════════════════════════════════════"
    echo "  Configure Claude Code Permissions (Optional)"
    echo "═══════════════════════════════════════════════════════"
    echo ""
    echo "Review-code needs permission to run helper scripts."
    echo ""
    echo "You can either:"
    echo "  1. Pre-authorize scripts now (recommended)"
    echo "  2. Approve each script when Claude Code asks"
    echo ""
    read -p "Pre-authorize review-code scripts? [Y/n] " -n 1 -r
    echo ""

    if [[ ! ${REPLY} =~ ^[Nn]$ ]]; then
        if [[ -f "${SCRIPT_DIR}/bin/manage-permissions" ]]; then
            "${SCRIPT_DIR}/bin/manage-permissions" add
        else
            warn "manage-permissions script not found"
            warn "You'll need to approve permissions when Claude Code asks"
        fi
    else
        echo ""
        info "Skipped automatic permission configuration"
        echo "  You'll be prompted to approve scripts when they run"
        echo "  To configure later, run: bin/manage-permissions add"
    fi
}

show_next_steps() {
    echo ""
    echo "═══════════════════════════════════════════════════════"
    echo "  Next Steps"
    echo "═══════════════════════════════════════════════════════"
    echo ""
    echo "Review-code uses helper scripts that need permission to run."
    echo ""
    echo "When Claude Code asks to run a script, you'll see:"
    echo "  • Script name (e.g., git-context.sh)"
    echo "  • What it does (e.g., Extract repo metadata)"
    echo ""
    echo "All scripts are READ-ONLY and only analyze your code."
    echo ""
    echo "Tip: Choose 'Always allow' to avoid repeated prompts."
    echo ""
}

main() {
    echo ""
    echo "═══════════════════════════════════════════════════════"
    echo "  Review-Code Local Installation"
    echo "═══════════════════════════════════════════════════════"
    echo ""

    # Check prerequisites
    info "Checking prerequisites…"
    check_prerequisites

    # Verify repository structure
    info "Verifying repository structure…"
    verify_repo_structure

    # Check for old installation (returns 0=remove, 1=keep, 2=none)
    set +e
    check_old_installation
    local remove_old=$?
    set -e

    # Migrate old config file location if needed
    migrate_old_config

    # Get review path
    review_path=$(get_review_path)

    # Cleanup old command-based installation if exists
    cleanup_old_command

    # Install components
    echo ""
    info "Installing review-code components…"
    create_config "${review_path}"
    install_skill
    install_agents
    install_context "${review_path}"

    # Prompt for permission configuration
    prompt_configure_permissions

    # Cleanup old installation if requested
    if [[ "${remove_old}" -eq 0 ]]; then
        echo ""
        cleanup_old_installation
    fi

    # Show next steps
    show_next_steps

    # Success summary
    echo ""
    echo "═══════════════════════════════════════════════════════"
    echo ""
    info "Installation complete!"
    echo ""
    echo "Review-code is now ready to use:"
    echo "  - Run: /review-code"
    echo "  - Review PR: /review-code <pr-number>"
    echo "  - Specific review: /review-code security"
    echo ""
    echo "Configure permissions:"
    echo "  - Add: bin/manage-permissions add"
    echo "  - Remove: bin/manage-permissions remove"
    echo "  - Status: bin/manage-permissions status"
    echo "  - Or approve individually when prompted"
    echo ""
    echo "Installation locations:"
    echo "  - Config: ${CONFIG_FILE}"
    echo "  - Skill: ${CLAUDE_DIR}/skills/review-code/"
    echo "  - Agents: ${CLAUDE_DIR}/agents/"
    echo "  - Context: ${review_path}/context/"
    echo "  - Reviews: ${review_path}/{org}/{repo}/"
    echo ""
    echo "To update: Run bin/setup again"
    echo "To uninstall: Run uninstall.sh"
    echo ""
    echo "═══════════════════════════════════════════════════════"
    echo ""
}

main "$@"
